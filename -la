[1mdiff --git a/prj.conf b/prj.conf[m
[1mindex 9caf15a..daabb10 100644[m
[1m--- a/prj.conf[m
[1m+++ b/prj.conf[m
[36m@@ -1,4 +1,7 @@[m
 CONFIG_SERIAL=y[m
 CONFIG_UART_INTERRUPT_DRIVEN=y[m
 CONFIG_MAIN_STACK_SIZE=8192[m
[31m-CONFIG_NEWLIB_LIBC=y[m
\ No newline at end of file[m
[32m+[m[32mCONFIG_NEWLIB_LIBC=y[m
[32m+[m[32mCONFIG_PRINTK=y[m
[32m+[m[32mCONFIG_PWM=y[m
[32m+[m[32mCONFIG_LOG=y[m
[1mdiff --git a/src/isbd.c b/src/isbd.c[m
[1mindex a96c032..eff356b 100644[m
[1m--- a/src/isbd.c[m
[1m+++ b/src/isbd.c[m
[36m@@ -19,7 +19,7 @@[m
  * @brief Long timeout is used for commands which take longer[m
  * than 1 seconds, for example: AT+SBDI, AT+SBDIX, AT+CSQ, ...[m
  */[m
[31m-#define LONG_TIMEOUT_RESPONSE       (30 * 1000) // ms[m
[32m+[m[32m#define LONG_TIMEOUT_RESPONSE       (60 * 1000) // ms[m
 [m
 struct isbd {[m
   struct isbd_config config;[m
[36m@@ -279,6 +279,21 @@[m [mat_uart_code_t _isbd_pack_bin_resp([m
   return at_uart_skip_txt_resp( AT_1_LINE_RESP, timeout_ms );[m
 }[m
 [m
[32m+[m[32mint8_t isbd_get_sig_q( uint8_t *signal ) {[m
[32m+[m
[32m+[m[32m  char __buff[ 16 ];[m
[32m+[m[32m  SEND_AT_CMD_E( "+csq" );[m
[32m+[m[41m  [m
[32m+[m[32m  at_uart_code_t at_code = at_uart_pack_txt_resp([m
[32m+[m[32m    __buff, sizeof( __buff ), AT_2_LINE_RESP, LONG_TIMEOUT_RESPONSE );[m
[32m+[m
[32m+[m[32m  if ( at_code == AT_UART_OK ) {[m
[32m+[m[32m    sscanf( __buff, "+CSQ:%hhd", signal );[m[41m [m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  return at_code;[m
[32m+[m[32m}[m
[32m+[m
 int8_t _isbd_using_three_wire_connection( bool using ) {[m
   [m
   at_uart_code_t at_code;[m
[1mdiff --git a/src/isbd.h b/src/isbd.h[m
[1mindex d9c234f..e9e49b8 100644[m
[1m--- a/src/isbd.h[m
[1m+++ b/src/isbd.h[m
[36m@@ -123,4 +123,13 @@[m
    */[m
   int8_t isbd_clear_buffer( isbd_clear_buffer_t buffer );[m
 [m
[32m+[m[32m  /**[m
[32m+[m[32m   * @brief Execution command returns the received signal strength indication <rssi> from the 9602. Response is in[m
[32m+[m[32mthe form:[m
[32m+[m[32m   *[m[41m [m
[32m+[m[32m   * @param signal[m[41m [m
[32m+[m[32m   * @return int8_t[m[41m [m
[32m+[m[32m   */[m
[32m+[m[32m  int8_t isbd_get_sig_q( uint8_t *signal );[m
[32m+[m
 #endif[m
\ No newline at end of file[m
[1mdiff --git a/src/main.c b/src/main.c[m
[1mindex ea30c3d..c5ca566 100644[m
[1m--- a/src/main.c[m
[1m+++ b/src/main.c[m
[36m@@ -7,7 +7,7 @@[m
 #include <zephyr/kernel.h>[m
 #include <zephyr/device.h>[m
 #include <zephyr/drivers/uart.h>[m
[31m-#include <zephyr/devicetree.h>[m
[32m+[m[32m#include <zephyr/drivers/gpio.h>[m
 [m
 #include <string.h>[m
 #include <stdio.h>[m
[36m@@ -22,134 +22,19 @@[m
 #define PRIORITY		  5[m
 [m
 /* change this to any other UART peripheral if desired */[m
[31m-#define UART_MASTER_DEVICE_NODE DT_NODELABEL(uart0)[m
[32m+[m[32m// #define UART_MASTER_DEVICE_NODE DT_NODELABEL(uart0)[m
 #define UART_SLAVE_DEVICE_NODE DT_NODELABEL(uart3)[m
 [m
[31m-void master_serial_entry( void*, void*, void* );[m
[31m-[m
[31m-K_THREAD_DEFINE(master_tid, STACK_SIZE,[m
[31m-                master_serial_entry, NULL, NULL, NULL,[m
[31m-                PRIORITY, 0, 0);[m
[31m-[m
[31m-/* queue to store up to 10 messages (aligned to 4-byte boundary) */[m
[31m-K_MSGQ_DEFINE(uart_master_msgq, MSG_SIZE, 10, 4);[m
[31m-[m
[31m-static const struct device *const uart_master_device = DEVICE_DT_GET(UART_MASTER_DEVICE_NODE); [m
 static const struct device *const uart_slave_device = DEVICE_DT_GET(UART_SLAVE_DEVICE_NODE);[m
 [m
[31m-struct serial_rx_buff {[m
[31m-	int pos;[m
[31m-	char buff[MSG_SIZE];[m
[31m-	struct k_msgq *msgq;[m
[31m-};[m
[31m-[m
[31m-static struct serial_rx_buff slave_rx_buff;[m
[31m-static struct serial_rx_buff master_rx_buff;[m
[31m-[m
[31m-/*[m
[31m- * Read characters from UART until line end is detected. Afterwards push the[m
[31m- * data to the message queue.[m
[31m- */[m
[31m-void serial_cb(const struct device *dev, void *user_data)[m
[31m-{[m
[31m-	uint8_t c;[m
[31m-	struct serial_rx_buff *rx_buff = (struct serial_rx_buff*)user_data;[m
[31m-[m
[31m-	if (!uart_irq_update(dev)) {[m
[31m-		return;[m
[31m-	}[m
[31m-[m
[31m-	if (!uart_irq_rx_ready(dev)) {[m
[31m-		return;[m
[31m-	}[m
[31m-[m
[31m-	/* read until FIFO empty */[m
[31m-	while (uart_fifo_read(dev, &c, 1) == 1) {[m
[31m-[m
[31m-		if (c == '\n' || c == '\r') {[m
[31m-			[m
[31m-			/* terminate string */[m
[31m-			rx_buff->buff[rx_buff->pos] = '\0';[m
[31m-[m
[31m-			if ( rx_buff->pos > 0 ) {[m
[31m-				/* if queue is full, message is silently dropped */[m
[31m-				k_msgq_put(rx_buff->msgq, &rx_buff->buff, K_NO_WAIT);[m
[31m-			}[m
[31m-			[m
[31m-			/* reset the buffer (it was copied to the msgq) */[m
[31m-			rx_buff->pos = 0;[m
[31m-		} else if (rx_buff->pos < (MSG_SIZE - 1)) {[m
[31m-			rx_buff->buff[rx_buff->pos++] = c;[m
[31m-		}[m
[31m-		/* else: characters beyond buffer size are dropped */[m
[31m-	}[m
[31m-}[m
[31m-[m
[31m-/*[m
[31m- * Print a null-terminated string character by character to the UART interface[m
[31m- */[m
[31m-void print_uart( const struct device *uart_dev, char *buf)[m
[31m-{[m
[31m-	int msg_len = strlen(buf);[m
[31m-	for (int i = 0; i < msg_len; i++) {[m
[31m-		uart_poll_out(uart_dev, buf[i]);[m
[31m-	}[m
[31m-}[m
[31m-[m
[31m-void setup_uart( const struct device *uart_dev, struct serial_rx_buff *rx_buff, struct k_msgq *msgq ) {[m
[31m-	[m
[31m-	rx_buff->msgq = msgq;[m
[31m-[m
[31m-	int ret = uart_irq_callback_user_data_set(uart_dev, serial_cb, rx_buff);[m
[32m+[m[32m/* The devicetree node identifier for the "led0" alias. */[m
[32m+[m[32m#define LED0_NODE DT_ALIAS(led0)[m
[32m+[m[32m#define LED2_NODE DT_ALIAS(led2)[m
 [m
[31m-	if (ret < 0) {[m
[31m-		if (ret == -ENOTSUP) {[m
[31m-			printk("Interrupt-driven UART API support not enabled\n");[m
[31m-		} else if (ret == -ENOSYS) {[m
[31m-			printk("UART device does not support interrupt-driven API\n");[m
[31m-		} else {[m
[31m-			printk("Error setting UART callback: %d\n", ret);[m
[31m-		}[m
[31m-		return;[m
[31m-	}[m
[31m-	[m
[31m-  uart_irq_rx_enable( uart_dev );[m
[31m-[m
[31m-}[m
[31m-[m
[31m-void master_serial_entry( void *p1, void *p2, void *p3 ) {[m
[31m-[m
[31m-  return;[m
[31m-  [m
[31m-	char tx_buf[MSG_SIZE];[m
[31m-	struct uart_config config;[m
[32m+[m[32mstatic const struct gpio_dt_spec red_led = GPIO_DT_SPEC_GET( LED2_NODE, gpios );[m
[32m+[m[32mstatic const struct gpio_dt_spec green_led = GPIO_DT_SPEC_GET( LED0_NODE, gpios );[m
 [m
[31m-	uart_config_get( uart_master_device, &config );[m
[31m-	config.baudrate = 115200;[m
[31m-	uart_configure( uart_master_device, &config );[m
[31m-[m
[31m-	setup_uart( uart_master_device, &master_rx_buff, &uart_master_msgq );[m
[31m-[m
[31m-	/* indefinitely wait for input from the master message queue */[m
[31m-	while (k_msgq_get(&uart_master_msgq, &tx_buf, K_FOREVER) == 0) {[m
[31m-[m
[31m-		print_uart( uart_slave_device, tx_buf );[m
[31m-		print_uart( uart_slave_device, "\r\n" );[m
[31m-[m
[31m-		print_uart( uart_master_device, "Host -> 9602: " );[m
[31m-		print_uart( uart_master_device, tx_buf );[m
[31m-		print_uart( uart_master_device, "\r\n" );[m
[31m-	}[m
[31m-[m
[31m-}[m
[31m-[m
[31m-void check_err( isbd_err_t err ) {[m
[31m-  if ( err != 0 ) { [m
[31m-    printk( "Command failed: %d\n", err ); [m
[31m-  }[m
[31m-}[m
[31m-[m
[31m-#define CHECK_AT_CMD(ok_block, f_name, ... ) \[m
[32m+[m[32m#define TEST_AT_CMD(ok_block, f_name, ... ) \[m
 do { \[m
   printk( "%-20s() ", #f_name ); \[m
   uint8_t M_g_code = f_name( __VA_ARGS__ ); \[m
[36m@@ -164,15 +49,16 @@[m [mdo { \[m
 [m
 void main(void) {[m
 [m
[31m-	if (!device_is_ready(uart_master_device)) {[m
[31m-		printk("UART master device not found!");[m
[31m-		return;[m
[31m-	}[m
[32m+[m[32m  /*[m
[32m+[m[32m  if ( !gpio_is_ready_dt(&led) ) {[m
[32m+[m[32m    return;[m
[32m+[m[32m  }[m
[32m+[m[32m  */[m
 [m
 	if (!device_is_ready(uart_slave_device)) {[m
 		printk("UART slave device not found!");[m
 		return;[m
[31m-	}[m
[32m+[m[32m  }[m
 [m
 	// print_uart( uart_master_device, "Hello! I'm your echo bot for Iridium 9602 module.\r\n\r\n" );[m
 [m
[36m@@ -200,34 +86,40 @@[m [mvoid main(void) {[m
   // isbd_fetch_imei( __buff, sizeof( __buff ) );[m
   // CHECK_AT_CMD( code, {}, isbd_enable_echo, true );[m
 [m
[31m-  CHECK_AT_CMD({[m
[32m+[m[32m  TEST_AT_CMD({[m
     printk( "Revision : %s", __buff );[m
   }, isbd_get_revision, __buff, sizeof( __buff ) );  [m
 [m
[31m-  CHECK_AT_CMD({[m
[32m+[m[32m  TEST_AT_CMD({[m
     printk( "IMEI : %s", __buff );[m
   }, isbd_get_imei, __buff, sizeof( __buff ) );  [m
 [m
   const char *msg = "hello";[m
 [m
[31m-  CHECK_AT_CMD({}, isbd_set_mo, msg, strlen( msg ) );[m
[32m+[m[32m  TEST_AT_CMD({}, isbd_set_mo, msg, strlen( msg ) );[m
 [m
[31m-  CHECK_AT_CMD({[m
[32m+[m[32m  TEST_AT_CMD({[m
     printk( "%s", __buff );[m
   }, isbd_mo_to_mt, __buff, sizeof( __buff ) );[m
 [m
[32m+[m[41m  [m
 [m
   uint16_t csum;[m
   size_t len = sizeof( __buff );[m
 [m
[31m-  CHECK_AT_CMD({[m
[32m+[m[32m  TEST_AT_CMD({[m
     printk("msg=");[m
     for ( int i=0; i < len; i++ ) {[m
       printk( "%c", __buff[ i ] );[m
     }[m
     printk( ", len=%d, csum=%04X", len, csum );[m
   }, isbd_get_mt, __buff, &len, &csum );[m
[31m- [m
[32m+[m[41m  [m
[32m+[m[32m  uint8_t signal;[m
[32m+[m[32m  TEST_AT_CMD({[m
[32m+[m[32m    printk( "signal_quality=%d", signal );[m
[32m+[m[32m  }, isbd_get_sig_q, &signal );[m
[32m+[m
   // code = isbd_set_mo_bin( msg, strlen( msg ) );[m
 [m
   // code = isbd_clear_buffer( ISBD_CLEAR_MO_BUFF );[m
[36m@@ -244,10 +136,10 @@[m [mvoid main(void) {[m
   printk( " @ len = %d, csum = %04X\n", len, csum );[m
   */[m
   [m
[31m-[m
   isbd_session_t session;[m
 [m
[31m-  CHECK_AT_CMD({[m
[32m+[m[32m  TEST_AT_CMD({[m
[32m+[m
     printk( "mo_sts=%hhu, "[m
           "mo_msn=%hu, "[m
           "mt_sts=%hhu, "[m
[36m@@ -261,8 +153,13 @@[m [mvoid main(void) {[m
     session.mt_len,[m
     session.mt_queued );[m
 [m
[31m-  }, isbd_init_session, &session );[m
[32m+[m[32m    if ( session.mo_sts < 3 ) {[m
[32m+[m[32m      gpio_pin_configure_dt( &green_led, GPIO_OUTPUT_ACTIVE );[m
[32m+[m[32m    } else {[m
[32m+[m[32m      gpio_pin_configure_dt( &red_led, GPIO_OUTPUT_ACTIVE );[m
[32m+[m[32m    }[m
 [m
[32m+[m[32m  }, isbd_init_session, &session );[m
 [m
 [m
   // int8_t cmd_code = isbd_set_mo_txt( "hoooooo" );[m
