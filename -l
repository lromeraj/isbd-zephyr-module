[1mdiff --git a/.vscode/settings.json b/.vscode/settings.json[m
[1mindex aa336a5..a6df33a 100644[m
[1m--- a/.vscode/settings.json[m
[1m+++ b/.vscode/settings.json[m
[36m@@ -10,6 +10,7 @@[m
       "typeinfo": "c",[m
       "system_error": "c",[m
       "defs.h": "c",[m
[31m-      "at.h": "c"[m
[32m+[m[32m      "at.h": "c",[m
[32m+[m[32m      "type_traits": "c"[m
     }[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/src/at.c b/src/at.c[m
[1mindex ba8de4a..a214676 100644[m
[1m--- a/src/at.c[m
[1m+++ b/src/at.c[m
[36m@@ -1,30 +1,30 @@[m
 #include "at.h"[m
 [m
[31m-#define AT_STR          "at"[m
[31m-[m
[31m-#define AT_CMD_Q_CHAR   "?"[m
[31m-#define AT_CMD_EQ_CHAR  "="[m
[32m+[m[32m#define AT_STR           "at"[m
[32m+[m[32m#define AT_CMD_Q_STR     "?"[m
[32m+[m[32m#define AT_CMD_EQ_STR    "="[m
 [m
 // AT command prefix[m
[31m-#define AT_CMD_H__          AT_STR[m
[31m-[m
[31m-// AT command end of line[m
[31m-#define __AT_EOL          "\r"[m
[32m+[m[32m#define AT_CMD_H          AT_STR[m
 [m
 // AT command read suffix[m
[31m-#define __AT_CMD_READ     AT_CMD_Q_CHAR __AT_EOL[m
[32m+[m[32m#define AT_CMD_READ       AT_CMD_Q_STR AT_CMD_EOL[m
 [m
 // AT command test suffix[m
[31m-#define __AT_CMD_TEST     AT_CMD_EQ_CHAR AT_CMD_EQ_CHAR __AT_EOL[m
[32m+[m[32m#define AT_CMD_TEST       AT_CMD_EQ_STR AT_CMD_Q_STR AT_CMD_EOL[m
[32m+[m
[32m+[m[32m// AT command end of line[m
[32m+[m[32m#define AT_CMD_EOL        "\r"[m
[32m+[m
 [m
 /**[m
  * @brief This macro is used to safely write into[m
  * a predefined AT buffer. Returns the number of bytes written into the buffer.[m
  */[m
 #define BUILD_AT_CMD_RET( buff, ... ) \[m
[31m-  uint8_t M_written = snprintf( buff, AT_MAX_CMD_SIZE, __VA_ARGS__ ); \[m
[31m-  if ( M_written < AT_MAX_CMD_SIZE ) { \[m
[31m-    return M_written; \[m
[32m+[m[32m  uint8_t _M_written = snprintf( buff, AT_MAX_CMD_SIZE, __VA_ARGS__ ); \[m
[32m+[m[32m  if ( _M_written < AT_MAX_CMD_SIZE ) { \[m
[32m+[m[32m    return _M_written; \[m
   } else { \[m
     return AT_MAX_CMD_SIZE-1; \[m
   }[m
[36m@@ -32,29 +32,29 @@[m
 // exec[m
 uint8_t at_cmd_e( char *at_buf, const char *cmd_name ) {[m
   BUILD_AT_CMD_RET( [m
[31m-    at_buf, AT_CMD_H__ "%s" __AT_EOL, cmd_name );[m
[32m+[m[32m    at_buf, AT_CMD_H "%s" AT_CMD_EOL, cmd_name );[m
 }[m
 [m
 // exec with param[m
 uint8_t at_cmd_p( char *at_buf, const char *cmd_name, uint8_t param ) {[m
   BUILD_AT_CMD_RET( [m
[31m-    at_buf, AT_CMD_H__ "%s%hhu" __AT_EOL, cmd_name, param );[m
[32m+[m[32m    at_buf, AT_CMD_H "%s%hhu" AT_CMD_EOL, cmd_name, param );[m
 }[m
 [m
 // test[m
 uint8_t at_cmd_t( char *at_buf, const char *cmd_name ) {[m
   BUILD_AT_CMD_RET([m
[31m-    at_buf, AT_CMD_H__ "%s" __AT_CMD_TEST, cmd_name );[m
[32m+[m[32m    at_buf, AT_CMD_H "%s" AT_CMD_TEST, cmd_name );[m
 }[m
 [m
 // read[m
 uint8_t at_cmd_r( char *at_buf, const char *cmd_name ) {[m
   BUILD_AT_CMD_RET( [m
[31m-    at_buf, AT_CMD_H__ "%s" __AT_CMD_READ, cmd_name );[m
[32m+[m[32m    at_buf, AT_CMD_H "%s" AT_CMD_READ, cmd_name );[m
 }[m
 [m
 // set[m
 uint8_t at_cmd_s( char *at_buf, const char *cmd_name, const char *params ) {[m
   BUILD_AT_CMD_RET([m
[31m-    at_buf, AT_CMD_H__ "%s" AT_CMD_EQ_CHAR "%s" __AT_EOL, cmd_name, params );[m
[32m+[m[32m    at_buf, AT_CMD_H "%s" AT_CMD_EQ_STR "%s" AT_CMD_EOL, cmd_name, params );[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/src/isbd.c b/src/isbd.c[m
[1mindex eff356b..9c95e4b 100644[m
[1m--- a/src/isbd.c[m
[1m+++ b/src/isbd.c[m
[36m@@ -27,10 +27,10 @@[m [mstruct isbd {[m
 [m
 static struct isbd g_isbd = {  };[m
 [m
[31m-at_uart_code_t _isbd_pack_bin_resp( [m
[31m-  uint8_t *__msg, size_t *msg_len, uint16_t *csum, uint16_t timeout_ms [m
[32m+[m[32mstatic at_uart_code_t _isbd_pack_bin_resp([m[41m [m
[32m+[m[32m  uint8_t *msg_buf, size_t *msg_buf_len, uint16_t *csum, uint16_t timeout_ms[m[41m [m
 );[m
[31m-int8_t _isbd_using_three_wire_connection( bool using );[m
[32m+[m[32mstatic int8_t _isbd_using_three_wire_connection( bool using );[m
 [m
 isbd_err_t isbd_setup( struct isbd_config *isbd_config ) {[m
  [m
[36m@@ -58,37 +58,39 @@[m [misbd_err_t isbd_setup( struct isbd_config *isbd_config ) {[m
   return at_code == AT_UART_OK ? ISBD_OK : ISBD_ERR;[m
 }[m
 [m
[31m-int8_t isbd_get_imei( char *__imei, size_t imei_len ) {[m
[31m-  SEND_AT_CMD_E( "+cgsn" );[m
[32m+[m[32mint8_t isbd_get_imei( char *imei_buf, size_t imei_buf_len ) {[m
[32m+[m[32m  SEND_AT_CMD_E_OR_RET( "+cgsn" );[m
   return at_uart_pack_txt_resp([m
[31m-    __imei, imei_len, AT_2_LINE_RESP, SHORT_TIMEOUT_RESPONSE );[m
[32m+[m[32m    imei_buf, imei_buf_len, AT_2_LINE_RESP, SHORT_TIMEOUT_RESPONSE );[m
 }[m
 [m
[31m-int8_t isbd_get_revision( char *__revision, size_t revision_len ) {[m
[31m-  SEND_AT_CMD_E( "+cgmr" );[m
[32m+[m[32mint8_t isbd_get_revision( char *rev_buf, size_t rev_buf_len ) {[m
[32m+[m[32m  SEND_AT_CMD_E_OR_RET( "+cgmr" );[m
   return at_uart_pack_txt_resp( [m
     // TODO: Measure exact lines from AT+CGMR[m
[31m-    __revision, revision_len, 10, SHORT_TIMEOUT_RESPONSE );[m
[32m+[m[32m    rev_buf, rev_buf_len, 10, SHORT_TIMEOUT_RESPONSE );[m
 }[m
 [m
[31m-int8_t isbd_get_rtc( char *__rtc, size_t rtc_len ) {[m
[31m-  SEND_AT_CMD_E( "+cclk" );[m
[32m+[m[32m// TODO: parse the output of this command in order to return[m
[32m+[m[32m// TODO: a more human friendly time struct[m
[32m+[m[32mint8_t isbd_get_rtc( char *rtc_buf, size_t rtc_buf_len ) {[m
[32m+[m[32m  SEND_AT_CMD_E_OR_RET( "+cclk" );[m
   return at_uart_pack_txt_resp( [m
[31m-    __rtc, rtc_len, AT_2_LINE_RESP, SHORT_TIMEOUT_RESPONSE );[m
[32m+[m[32m    rtc_buf, rtc_buf_len, AT_2_LINE_RESP, SHORT_TIMEOUT_RESPONSE );[m
 }[m
 [m
 int8_t isbd_init_session( isbd_session_t *session ) {[m
 [m
[31m-  char __buff[ 64 ];[m
[32m+[m[32m  char buff[ 64 ];[m
   [m
   at_uart_code_t at_code;[m
[31m-  SEND_AT_CMD_E( "+sbdix" );[m
[32m+[m[32m  SEND_AT_CMD_E_OR_RET( "+sbdix" );[m
 [m
   at_code = at_uart_pack_txt_resp([m
[31m-    __buff, sizeof( __buff ), AT_2_LINE_RESP, LONG_TIMEOUT_RESPONSE );[m
[32m+[m[32m    buff, sizeof( buff ), AT_2_LINE_RESP, LONG_TIMEOUT_RESPONSE );[m
   [m
   // TODO: implement optimized function instead of using sscanf[m
[31m-  sscanf( __buff, "+SBDIX:%hhu,%hu,%hhu,%hu,%hu,%hhu",[m
[32m+[m[32m  sscanf( buff, "+SBDIX:%hhu,%hu,%hhu,%hu,%hu,%hhu",[m
     &session->mo_sts,[m
     &session->mo_msn,[m
     &session->mt_sts,[m
[36m@@ -104,7 +106,7 @@[m [mint8_t isbd_clear_buffer( isbd_clear_buffer_t buffer ) {[m
 [m
   int8_t cmd_code;[m
   at_uart_code_t at_code;[m
[31m-  SEND_AT_CMD_P( "+sbdd", buffer );[m
[32m+[m[32m  SEND_AT_CMD_P_OR_RET( "+sbdd", buffer );[m
 [m
   // retrieve command response code[m
   // this is not AT command interface result code[m
[36m@@ -142,20 +144,22 @@[m [mint8_t isbd_set_mo_txt( const char *txt ) {[m
   }[m
   */[m
 [m
[31m-  SEND_AT_CMD_S( "+sbdwt", txt );[m
[32m+[m[32m  SEND_AT_CMD_S_OR_RET( "+sbdwt", txt );[m
   return at_uart_skip_txt_resp( [m
     AT_2_LINE_RESP, SHORT_TIMEOUT_RESPONSE );[m
 }[m
 [m
[31m-int8_t isbd_set_mo( const uint8_t *__msg, size_t msg_len ) {[m
[32m+[m[32mint8_t isbd_set_mo( const uint8_t *msg, size_t msg_len ) {[m
 [m
   // TODO: __data buffer is not mandatory and should be[m
   // TODO: removed in future modifications[m
[31m-  uint8_t __data[ msg_len + 2 ];[m
[32m+[m[32m  uint8_t tx_buf_size = msg_len + 2;[m
[32m+[m[32m  uint8_t tx_buf[ tx_buf_size ];[m
 [m
[31m-  unsigned char __len[ 8 ];[m
[31m-  snprintf( __len, sizeof( __len ), "%d", msg_len );[m
[31m-  SEND_AT_CMD_S( "+sbdwb", __len );[m
[32m+[m[32m  unsigned char msg_len_buf[ 8 ];[m
[32m+[m[32m  snprintf( msg_len_buf, sizeof( msg_len_buf ), "%d", msg_len );[m
[32m+[m
[32m+[m[32m  SEND_AT_CMD_S_OR_RET( "+sbdwb", msg_len_buf );[m
 [m
   int8_t cmd_code;[m
   at_uart_code_t at_code;[m
[36m@@ -165,6 +169,8 @@[m [mint8_t isbd_set_mo( const uint8_t *__msg, size_t msg_len ) {[m
   // but if the length is not correct or some other validity check[m
   // fails, the resulting value will be a code corresponding to [m
   // the command context and not to the AT command interface itself[m
[32m+[m[32m  // So if the returned code from this function is not AT_UART_OK, cmd_code[m
[32m+[m[32m  // will NOT be updated[m
   at_code = [m
     at_uart_pack_txt_resp_code( &cmd_code, SHORT_TIMEOUT_RESPONSE );[m
 [m
[36m@@ -173,32 +179,31 @@[m [mint8_t isbd_set_mo( const uint8_t *__msg, size_t msg_len ) {[m
     // compute message checksum[m
     uint32_t sum = 0;[m
     for ( int i=0; i < msg_len; i++ ) {[m
[31m-      sum += __data[ i ] = __msg[ i ];[m
[32m+[m[32m      sum += tx_buf[ i ] = msg[ i ];[m
     }[m
 [m
[31m-    uint16_t *csum = (uint16_t*)&__data[ msg_len ];[m
[32m+[m[32m    uint16_t *csum = (uint16_t*)&tx_buf[ msg_len ];[m
     *csum = htons( sum & 0xFFFF );[m
 [m
     // finally write binary data to the ISU[m
     // MSG (N bytes) + CHECKSUM (2 bytes)[m
[31m-    at_uart_write( __data, msg_len + 2 );[m
[32m+[m[32m    at_uart_write( tx_buf, tx_buf_size );[m
 [m
     // retrieve the command result code[m
     at_uart_pack_txt_resp_code( [m
       &cmd_code, SHORT_TIMEOUT_RESPONSE ); [m
[31m-[m
   }[m
 [m
[31m-  // always fetch last AT command[m
[31m-  at_code = at_uart_skip_txt_resp( [m
[32m+[m[32m  // always fetch last AT command result[m
[32m+[m[32m  at_code = at_uart_skip_txt_resp([m
     AT_1_LINE_RESP, SHORT_TIMEOUT_RESPONSE );[m
 [m
   return at_code == AT_UART_OK ? cmd_code : at_code;[m
 }[m
 [m
 int8_t isbd_get_mt( uint8_t *__msg, size_t *msg_len, uint16_t *csum ) {[m
[31m-  SEND_AT_CMD_E( "+sbdrb" );[m
[31m-  return _isbd_pack_bin_resp( [m
[32m+[m[32m  SEND_AT_CMD_E_OR_RET( "+sbdrb" );[m
[32m+[m[32m  return _isbd_pack_bin_resp([m
     __msg, msg_len, csum, SHORT_TIMEOUT_RESPONSE );[m
 }[m
 [m
[36m@@ -228,20 +233,18 @@[m [mint8_t isbd_set_mo_txt_l( char *__txt ) {[m
 */[m
 [m
 int8_t isbd_mo_to_mt( char *__out, size_t out_len ) {[m
[31m-  SEND_AT_CMD_E( "+sbdtc" );[m
[32m+[m[32m  SEND_AT_CMD_E_OR_RET( "+sbdtc" );[m
   return at_uart_pack_txt_resp([m
     __out, out_len, AT_2_LINE_RESP, SHORT_TIMEOUT_RESPONSE );[m
 }[m
 [m
 int8_t isbd_get_mt_txt( char *__mt_buff, size_t mt_buff_len ) {[m
   [m
[31m-  SEND_AT_CMD_E( "+sbdrt" );[m
[31m-[m
[31m-  if ( g_isbd.config.at_uart.verbose ) {[m
[31m-    [m
[32m+[m[32m  SEND_AT_CMD_E_OR_RET( "+sbdrt" );[m
[32m+[m[41m  [m
[32m+[m[32m  if ( g_isbd.config.at_uart.verbose ) {[m[41m  [m
     return at_uart_pack_txt_resp( [m
       __mt_buff, mt_buff_len, AT_3_LINE_RESP, SHORT_TIMEOUT_RESPONSE );[m
[31m-[m
   } else {[m
     [m
     uint16_t len;[m
[36m@@ -263,15 +266,13 @@[m [mint8_t isbd_get_mt_txt( char *__mt_buff, size_t mt_buff_len ) {[m
 [m
 at_uart_code_t _isbd_pack_bin_resp([m
   // TODO: timeout could be implicitly specified[m
[31m-  uint8_t *__msg, size_t *msg_len, uint16_t *csum, uint16_t timeout_ms[m
[32m+[m[32m  uint8_t *msg_buf, size_t *msg_buf_len, uint16_t *csum, uint16_t timeout_ms[m
 ) {[m
 [m
[31m-  uint8_t byte;  [m
[31m-  [m
[31m-  at_uart_get_n_bytes( (uint8_t*)msg_len, 2, timeout_ms ); // message length[m
[31m-  *msg_len = ntohs( *msg_len );[m
[32m+[m[32m  at_uart_get_n_bytes( (uint8_t*)msg_buf_len, 2, timeout_ms ); // message length[m
[32m+[m[32m  *msg_buf_len = ntohs( *msg_buf_len );[m
 [m
[31m-  at_uart_get_n_bytes( __msg, *msg_len, timeout_ms );[m
[32m+[m[32m  at_uart_get_n_bytes( msg_buf, *msg_buf_len, timeout_ms );[m
 [m
   at_uart_get_n_bytes( (uint8_t*)csum, 2, timeout_ms );[m
   *csum = ntohs( *csum );[m
[36m@@ -279,22 +280,22 @@[m [mat_uart_code_t _isbd_pack_bin_resp([m
   return at_uart_skip_txt_resp( AT_1_LINE_RESP, timeout_ms );[m
 }[m
 [m
[31m-int8_t isbd_get_sig_q( uint8_t *signal ) {[m
[32m+[m[32mint8_t isbd_get_sig_q( uint8_t *signal_q ) {[m
 [m
[31m-  char __buff[ 16 ];[m
[31m-  SEND_AT_CMD_E( "+csq" );[m
[32m+[m[32m  char buf[ 16 ];[m
[32m+[m[32m  SEND_AT_CMD_E_OR_RET( "+csq" );[m
   [m
   at_uart_code_t at_code = at_uart_pack_txt_resp([m
[31m-    __buff, sizeof( __buff ), AT_2_LINE_RESP, LONG_TIMEOUT_RESPONSE );[m
[32m+[m[32m    buf, sizeof( buf ), AT_2_LINE_RESP, LONG_TIMEOUT_RESPONSE );[m
 [m
   if ( at_code == AT_UART_OK ) {[m
[31m-    sscanf( __buff, "+CSQ:%hhd", signal ); [m
[32m+[m[32m    sscanf( buf, "+CSQ:%hhd", signal_q );[m[41m [m
   }[m
 [m
   return at_code;[m
 }[m
 [m
[31m-int8_t _isbd_using_three_wire_connection( bool using ) {[m
[32m+[m[32mstatic int8_t _isbd_using_three_wire_connection( bool using ) {[m
   [m
   at_uart_code_t at_code;[m
   uint8_t en_param = using ? 0 : 3;[m
[1mdiff --git a/src/main.c b/src/main.c[m
[1mindex 386549b..4902f0f 100644[m
[1m--- a/src/main.c[m
[1m+++ b/src/main.c[m
[36m@@ -43,11 +43,11 @@[m [mdo { \[m
   if ( M_g_code == 0 ) { \[m
     printk( "OK; " ); \[m
     ok_block \[m
[31m-    printk( "\n" ); \[m
   } else { \[m
[31m-    printk( "ERR: %s\n", at_uart_err_to_name( M_g_code ) ); \[m
[32m+[m[32m    printk( "ERR: %s", at_uart_err_to_name( M_g_code ) ); \[m
     err_block \[m
   } \[m
[32m+[m[32m  printk( "\n" ); \[m
 } while(0)[m
 [m
 void main(void) {[m
[1mdiff --git a/src/uart.c b/src/uart.c[m
[1mindex 9e18010..75531ca 100644[m
[1m--- a/src/uart.c[m
[1m+++ b/src/uart.c[m
[36m@@ -5,9 +5,12 @@[m
 #include "uart.h"[m
 #include "utils.h"[m
 [m
[31m-// minumum buffer size required to prase at least[m
[31m-// AT string codes[m
[31m-#define AT_MIN_BUFF_SIZE  32[m
[32m+[m[32m// Minumum buffer size required to parse[m[41m [m
[32m+[m[32m// at least AT string codes[m
[32m+[m[32m#define AT_MIN_BUFF_SIZE          32[m
[32m+[m
[32m+[m[32m// Default AT short response timeout[m
[32m+[m[32m#define AT_RESP_SHORT_TIMEOUT     1000 // ms[m
 [m
 struct at_uart_buff {[m
   size_t rx_len;[m
[36m@@ -33,8 +36,9 @@[m [mstruct at_uart {[m
 static struct at_uart g_uart;[m
 [m
 // ------------- Private AT basic command methods ---------------[m
[31m-int8_t _at_uart_set_quiet( bool enable );[m
[31m-int8_t _at_uart_set_verbose( bool enable );[m
[32m+[m[32mstatic int8_t _at_uart_set_quiet( bool enable );[m
[32m+[m[32mstatic int8_t _at_uart_enable_echo( bool enable );[m
[32m+[m[32mstatic int8_t _at_uart_set_verbose( bool enable );[m
 [m
 /**[m
  * @brief Echo command characters.[m
[36m@@ -68,12 +72,12 @@[m [muint16_t at_uart_get_n_bytes([m
     [m
     // ! Interrupts can disable RX when queue starts[m
     // ! filling up, which probably means instant packet loss[m
[31m-    // ! so instead disabling RX the queue will skip (silently) those bytes[m
[32m+[m[32m    // ! so instead of disabling RX, the queue will skip (silently) those bytes[m
     // uart_irq_rx_enable( g_isbd.config.dev );[m
     // printk( "bin: %c\n", byte );[m
 [m
     if ( bytes ) {[m
[31m-      *bytes++ = byte; [m
[32m+[m[32m      *bytes++ = byte;[m
     }[m
     n_bytes--;[m
   }[m
[36m@@ -217,12 +221,14 @@[m [mat_uart_code_t at_uart_pack_txt_resp([m
 at_uart_code_t at_uart_pack_txt_resp_code( int8_t *cmd_code, uint16_t timeout_ms ) {[m
 [m
   // ! The size of this buff needs at least the size to store[m
[31m-  // ! command response codes which usually are between 0 and 9[m
[32m+[m[32m  // ! an AT command response code which usually are between 0 and 9[m
   char __cmd_code[ AT_MIN_BUFF_SIZE ] = "";[m
 [m
   at_uart_code_t at_code =[m
     at_uart_pack_txt_resp( __cmd_code, sizeof( __cmd_code ), AT_1_LINE_RESP, timeout_ms );[m
   [m
[32m+[m[32m  // ! We should considere conflicts when verbose mode is disabled,[m
[32m+[m[32m  // ! in which case returned AT interface codes are also numbers[m[41m [m
   if ( at_code == AT_UART_UNK ) {[m
     *cmd_code = atoi( __cmd_code );[m
     return AT_UART_OK;[m
[36m@@ -422,45 +428,53 @@[m [mconst char *at_uart_err_to_name( at_uart_code_t code ) {[m
 // ------ Non propietary AT basic commands implementation ------[m
 [m
 int8_t at_uart_set_flow_control( uint8_t option ) {[m
[31m-  SEND_AT_CMD_P( "&k", option );[m
[31m-  return at_uart_skip_txt_resp( AT_1_LINE_RESP, 100 );[m
[32m+[m[32m  SEND_AT_CMD_P_OR_RET( "&k", option );[m
[32m+[m[32m  return at_uart_skip_txt_resp([m[41m [m
[32m+[m[32m    AT_1_LINE_RESP, AT_RESP_SHORT_TIMEOUT );[m
 }[m
 [m
 int8_t at_uart_set_dtr( uint8_t option ) {[m
[31m-  SEND_AT_CMD_P( "&d", option );[m
[31m-  return at_uart_skip_txt_resp( AT_1_LINE_RESP, 100 );[m
[32m+[m[32m  SEND_AT_CMD_P_OR_RET( "&d", option );[m
[32m+[m[32m  return at_uart_skip_txt_resp([m[41m [m
[32m+[m[32m    AT_1_LINE_RESP, AT_RESP_SHORT_TIMEOUT );[m
 }[m
 [m
 int8_t at_uart_store_active_config( uint8_t profile ) {[m
[31m-  SEND_AT_CMD_P( "&w", profile );[m
[31m-  return at_uart_skip_txt_resp( AT_1_LINE_RESP, 100 );[m
[32m+[m[32m  SEND_AT_CMD_P_OR_RET( "&w", profile );[m
[32m+[m[32m  return at_uart_skip_txt_resp([m[41m [m
[32m+[m[32m    AT_1_LINE_RESP, AT_RESP_SHORT_TIMEOUT );[m
 }[m
 [m
 int8_t at_uart_set_reset_profile( uint8_t profile ) {[m
[31m-  SEND_AT_CMD_P( "&y", profile );[m
[31m-  return at_uart_skip_txt_resp( AT_1_LINE_RESP, 100 );[m
[32m+[m[32m  SEND_AT_CMD_P_OR_RET( "&y", profile );[m
[32m+[m[32m  return at_uart_skip_txt_resp([m[41m [m
[32m+[m[32m    AT_1_LINE_RESP, AT_RESP_SHORT_TIMEOUT );[m
 }[m
 [m
 int8_t at_uart_flush_to_eeprom() {[m
[31m-  SEND_AT_CMD_E( "*f" );[m
[31m-  return at_uart_skip_txt_resp( AT_1_LINE_RESP, 100 );[m
[32m+[m[32m  SEND_AT_CMD_E_OR_RET( "*f" );[m
[32m+[m[32m  return at_uart_skip_txt_resp([m[41m [m
[32m+[m[32m    AT_1_LINE_RESP, AT_RESP_SHORT_TIMEOUT );[m
 }[m
 [m
[31m-int8_t _at_uart_set_quiet( bool enable ) {[m
[31m-  SEND_AT_CMD_P( "q", enable );[m
[31m-  return at_uart_skip_txt_resp( AT_1_LINE_RESP, 100 );[m
[32m+[m[32mstatic int8_t _at_uart_set_quiet( bool enable ) {[m
[32m+[m[32m  SEND_AT_CMD_P_OR_RET( "q", enable );[m
[32m+[m[32m  return at_uart_skip_txt_resp([m[41m [m
[32m+[m[32m    AT_1_LINE_RESP, AT_RESP_SHORT_TIMEOUT );[m
 }[m
 [m
[31m-int8_t _at_uart_enable_echo( bool enable ) {[m
[32m+[m[32mstatic int8_t _at_uart_enable_echo( bool enable ) {[m
   g_uart.config.echo = enable;[m
[31m-  SEND_AT_CMD_P( "e", enable );[m
[31m-  return at_uart_skip_txt_resp( AT_1_LINE_RESP, 100 );[m
[32m+[m[32m  SEND_AT_CMD_P_OR_RET( "e", enable );[m
[32m+[m[32m  return at_uart_skip_txt_resp([m[41m [m
[32m+[m[32m    AT_1_LINE_RESP, AT_RESP_SHORT_TIMEOUT );[m
 }[m
 [m
[31m-int8_t _at_uart_set_verbose( bool enable ) {[m
[32m+[m[32mstatic int8_t _at_uart_set_verbose( bool enable ) {[m
   g_uart.config.verbose = enable;[m
[31m-  SEND_AT_CMD_P( "v", enable );[m
[31m-  return at_uart_skip_txt_resp( AT_1_LINE_RESP, 100 );[m
[32m+[m[32m  SEND_AT_CMD_P_OR_RET( "v", enable );[m
[32m+[m[32m  return at_uart_skip_txt_resp([m[41m [m
[32m+[m[32m    AT_1_LINE_RESP, AT_RESP_SHORT_TIMEOUT );[m
 }[m
 [m
[31m-// ---- End of propietary AT basic commands implementation -----[m
[32m+[m[32m// ---- End of propietary AT basic commands implementation -----[m
\ No newline at end of file[m
[1mdiff --git a/src/uart.h b/src/uart.h[m
[1mindex 4336f43..7e13f47 100644[m
[1m--- a/src/uart.h[m
[1m+++ b/src/uart.h[m
[36m@@ -13,33 +13,58 @@[m
   #define AT_2_LINE_RESP    2[m
   #define AT_3_LINE_RESP    3[m
 [m
[31m-  #define SEND_AT_CMD( fn, ... ) \[m
[32m+[m[32m  /**[m
[32m+[m[32m   * @brief Used to send a command and return automatically in case[m
[32m+[m[32m   * of failure[m
[32m+[m[32m   *[m[41m [m
[32m+[m[32m   * @note This macro defines a temporary buffer to store the AT[m
[32m+[m[32m   * command string, finally result code is used in order to return[m
[32m+[m[32m   * automatically or not[m
[32m+[m[32m   */[m
[32m+[m[32m  #define SEND_AT_CMD_OR_RET( fn, ... ) \[m
     do { \[m
[31m-      AT_DEFINE_CMD_BUFF( __M_at_buff ); \[m
[31m-      at_uart_code_t M_at_code = at_uart_write_cmd( \[m
[31m-        __M_at_buff, at_cmd##fn ( __M_at_buff, __VA_ARGS__ ) ); \[m
[31m-      if ( M_at_code != AT_UART_OK ) { return M_at_code; } \[m
[32m+[m[32m      AT_DEFINE_CMD_BUFF( _M_at_buff ); \[m
[32m+[m[32m      at_uart_code_t _M_at_code = at_uart_write_cmd( \[m
[32m+[m[32m        _M_at_buff, at_cmd##fn ( _M_at_buff, __VA_ARGS__ ) ); \[m
[32m+[m[32m      if ( _M_at_code != AT_UART_OK ) { return _M_at_code; } \[m
     } while ( 0 );[m
 [m
[31m-  // exec[m
[31m-  #define SEND_AT_CMD_E( name ) \[m
[31m-    SEND_AT_CMD( _e, name )[m
[31m-[m
[31m-  // equivalent to exec but using extra param[m
[31m-  #define SEND_AT_CMD_P( name, param ) \[m
[31m-    SEND_AT_CMD( _p, name, param )[m
[31m-[m
[31m-  // test[m
[31m-  #define SEND_AT_CMD_T( name ) \[m
[31m-    SEND_AT_CMD( _t, name )[m
[31m-[m
[31m-  // read[m
[31m-  #define SEND_AT_CMD_R( name, param ) \[m
[31m-    SEND_AT_CMD( _r, name, param )[m
[31m-[m
[31m-  // set[m
[31m-  #define SEND_AT_CMD_S( name, params ) \[m
[31m-    SEND_AT_CMD( _s, name, params )[m
[32m+[m[32m  /**[m
[32m+[m[32m   * @brief Exec AT command, returns in case of failure[m
[32m+[m[32m   * @param name AT command name[m
[32m+[m[32m   */[m
[32m+[m[32m  #define SEND_AT_CMD_E_OR_RET( name ) \[m
[32m+[m[32m    SEND_AT_CMD_OR_RET( _e, name )[m
[32m+[m
[32m+[m[32m  /**[m
[32m+[m[32m   * @brief Exec AT command with parameter in place, returns in case of failure[m
[32m+[m[32m   * @param name AT command name[m
[32m+[m[32m   * @param param Unsigned byte param, this number will be concatenated to the AT command name[m
[32m+[m[32m   */[m
[32m+[m[32m  #define SEND_AT_CMD_P_OR_RET( name, param ) \[m
[32m+[m[32m    SEND_AT_CMD_OR_RET( _p, name, param )[m
[32m+[m
[32m+[m[32m  /**[m
[32m+[m[32m   * @brief Test AT command, returns in case of failure[m
[32m+[m[32m   * @param name AT command name[m
[32m+[m[32m   */[m
[32m+[m[32m  #define SEND_AT_CMD_T_OR_RET( name ) \[m
[32m+[m[32m    SEND_AT_CMD_OR_RET( _t, name )[m
[32m+[m
[32m+[m[32m  /**[m
[32m+[m[32m   * @brief Read AT command, returns in case of failure[m
[32m+[m[32m   * @param name AT command name[m
[32m+[m[32m   */[m
[32m+[m[32m  #define SEND_AT_CMD_R_OR_RET( name ) \[m
[32m+[m[32m    SEND_AT_CMD_OR_RET( _r, name )[m
[32m+[m
[32m+[m[32m  /**[m
[32m+[m[32m   * @brief Set AT command, returns in case of failure[m
[32m+[m[32m   * @param name AT command name[m
[32m+[m[32m   * @param params A string which contains command parameters[m
[32m+[m[32m   */[m
[32m+[m[32m  #define SEND_AT_CMD_S_OR_RET( name, params ) \[m
[32m+[m[32m    SEND_AT_CMD_OR_RET( _s, name, params )[m
 [m
   typedef enum at_uart_code {[m
     AT_UART_TIMEOUT     = -2,[m
[36m@@ -57,14 +82,14 @@[m
 [m
   at_uart_code_t at_uart_setup( struct at_uart_config *at_uart_config );[m
 [m
[31m-  at_uart_code_t at_uart_get_str_code( const char *__buff );[m
[31m-  at_uart_code_t at_uart_write_cmd( char *__src_buf, size_t len );[m
[32m+[m[32m  at_uart_code_t at_uart_get_str_code( const char *str_buf );[m
[32m+[m[32m  at_uart_code_t at_uart_write_cmd( char *cmd, size_t cmd_len );[m
   [m
[31m-  uint16_t at_uart_write( uint8_t *__src_buf, size_t len );[m
[32m+[m[32m  uint16_t at_uart_write( uint8_t *buf, size_t buf_len );[m
   uint16_t at_uart_get_n_bytes( uint8_t *bytes, uint16_t n_bytes, uint16_t timeout_ms );[m
   [m
   at_uart_code_t at_uart_check_echo();[m
[31m-  at_uart_code_t at_uart_pack_txt_resp( char *__str_resp, size_t str_resp_len, uint8_t lines, uint16_t timeout_ms );[m
[32m+[m[32m  at_uart_code_t at_uart_pack_txt_resp( char *str_resp, size_t str_resp_len, uint8_t lines, uint16_t timeout_ms );[m
   at_uart_code_t at_uart_pack_txt_resp_code( int8_t *cmd_code, uint16_t timeout_ms );[m
   at_uart_code_t at_uart_skip_txt_resp( uint8_t lines, uint16_t timeout_ms );[m
 [m
